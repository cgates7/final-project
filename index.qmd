---
title: "2024 Catch Probability Data"
execute: 
  echo: false
---

```{r}
#| message: false
#| warning: false
# ==============================================================================
# 1. SETUP & DATA
# ==============================================================================
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, plotly, janitor, stringr)

# --- A. Data Fetching Functions ---
fetch_chunk <- function(start_date, end_date) {
  url <- paste0(
    "https://baseballsavant.mlb.com/statcast_search/csv",
    "?all=true&type=details",
    "&game_date_gt=", start_date,
    "&game_date_lt=", end_date,
    "&player_type=batter"
  )
  tryCatch({
    read.csv(url, stringsAsFactors = FALSE) %>% janitor::clean_names() %>% as_tibble()
  }, error = function(e) { return(tibble()) })
}

get_full_season_data <- function() {
  date_ranges <- list(
    c("2024-03-28", "2024-04-30"),
    c("2024-05-01", "2024-05-31"),
    c("2024-06-01", "2024-06-30"),
    c("2024-07-01", "2024-07-31"),
    c("2024-08-01", "2024-08-31"),
    c("2024-09-01", "2024-09-29")
  )
  map_dfr(date_ranges, ~fetch_chunk(.x[1], .x[2]))
}

# --- B. Execute Download ---
statcast_data <- get_full_season_data()

# ==============================================================================
# 2. STADIUM GEOMETRY
# ==============================================================================
stadium_dims <- tibble(
  team = c("ARI","ATL","BAL","BOS","CHC","CWS","CIN","CLE","COL","DET",
           "HOU","KC","LAA","LAD","MIA","MIL","MIN","NYM","NYY","OAK",
           "PHI","PIT","SD","SEA","SF","STL","TB","TEX","TOR","WSH"),
  d_lf = c(330, 335, 333, 310, 355, 330, 328, 325, 347, 342, 
           315, 330, 330, 330, 344, 344, 339, 335, 318, 330, 
           329, 325, 334, 331, 339, 336, 315, 329, 328, 336),
  d_lc = c(374, 385, 384, 379, 375, 375, 379, 370, 390, 370, 
           362, 385, 387, 375, 386, 371, 377, 370, 399, 375, 
           374, 383, 375, 378, 399, 375, 370, 372, 375, 377),
  d_cf = c(407, 400, 400, 390, 400, 400, 404, 400, 415, 420, 
           409, 410, 396, 395, 407, 400, 404, 408, 408, 400, 
           401, 399, 396, 401, 391, 400, 404, 408, 400, 402),
  d_rc = c(374, 375, 373, 420, 375, 375, 370, 375, 375, 365, 
           373, 385, 370, 375, 392, 374, 367, 370, 385, 375, 
           369, 375, 375, 381, 415, 375, 370, 374, 375, 370),
  d_rf = c(330, 325, 318, 302, 353, 335, 325, 325, 350, 330, 
           326, 330, 330, 330, 335, 345, 328, 330, 314, 330, 
           330, 320, 322, 326, 309, 335, 322, 326, 328, 335)
)

get_stadium_poly <- function(team_code) {
  s <- stadium_dims %>% filter(team == team_code)
  if(nrow(s) == 0) return(NULL)
  ref <- data.frame(
    angle = c(-45, -22.5, 0, 22.5, 45),
    dist  = c(s$d_lf, s$d_lc, s$d_cf, s$d_rc, s$d_rf)
  ) %>% mutate(rad=angle*pi/180, x=dist*sin(rad), y=dist*cos(rad))
  as.data.frame(spline(ref$x, ref$y, n = 100))
}

# ==============================================================================
# 3. PROCESSING & MODELING
# ==============================================================================
clean_data <- statcast_data %>%
  filter(
    events %in% c("field_out", "single", "double", "triple", "home_run", "sac_fly"),
    !bb_type %in% c("ground_ball", "popup"),
    !is.na(hit_distance_sc), !is.na(launch_speed), !is.na(launch_angle)
  ) %>%
  mutate(
    fielder_raw = str_extract(des, "(?<=fielder\\s)[^.,]+"),
    fielder_name = str_trim(fielder_raw),
    fielder_name = ifelse(is.na(fielder_name), "Unidentified", fielder_name),
    
    is_caught = ifelse(events %in% c("field_out", "sac_fly"), 1, 0),
    spray_angle = atan((hc_x - 125.42) / (198.27 - hc_y)) * 180 / pi,
    raw_x = (hc_x - 125.42) * 2.5,
    raw_y = (198.27 - hc_y) * 2.5,
    angle_deg = atan2(raw_x, raw_y) * 180 / pi
  )

catch_model <- glm(is_caught ~ launch_speed + launch_angle + hit_distance_sc + abs(spray_angle), 
                   data = clean_data, family = "binomial")
clean_data$predicted_prob <- predict(catch_model, clean_data, type = "response")

# ==============================================================================
# 4. PLOT CONSTRUCTION
# ==============================================================================
teams_with_data <- sort(unique(clean_data$home_team))
teams_with_geom <- unique(stadium_dims$team)
valid_teams <- intersect(teams_with_data, teams_with_geom)

if(length(valid_teams) == 0) stop("No matching teams found.")

fig <- plot_ly()
infield <- data.frame(x = c(0, 63, 0, -63, 0), y = c(0, 63, 126, 63, 0))

visibility_list <- list()
all_annotations <- list() 

# NEW: We now have 4 traces per team: Field, Infield, Hits, Outs
# The Scatter traces (Hits & Outs) are indices 3 and 4 relative to the team start
scatter_indices <- c() # We will populate this dynamically

for(i in seq_along(valid_teams)) {
  t <- valid_teams[i]
  
  # A. Geometry & Data
  s_geom <- stadium_dims %>% filter(team == t)
  poly_t <- get_stadium_poly(t)
  
  ref_pts <- data.frame(
    angle = c(-45, -22.5, 0, 22.5, 45), 
    dist = c(s_geom$d_lf, s_geom$d_lc, s_geom$d_cf, s_geom$d_rc, s_geom$d_rf)
  )
  get_fence_dist <- approxfun(ref_pts$angle, ref_pts$dist, rule = 2)
  
  data_t <- clean_data %>% 
    filter(home_team == t) %>%
    mutate(
      catch_prob = ifelse(events == "home_run", 0.0, predicted_prob),
      is_fair_hit = events %in% c("single", "double", "triple"),
      fixed_angle = case_when(
        is_fair_hit & angle_deg > 45 ~ 44, 
        is_fair_hit & angle_deg < -45 ~ -44, 
        TRUE ~ angle_deg
      ),
      current_dist = sqrt(raw_x^2 + raw_y^2),
      max_dist = get_fence_dist(fixed_angle),
      final_dist = case_when(
        events != "home_run" & current_dist >= max_dist ~ max_dist - 5,
        TRUE ~ current_dist
      ),
      coord_x = final_dist * sin(fixed_angle * pi / 180),
      coord_y = final_dist * cos(fixed_angle * pi / 180),
      
      display_fielder = ifelse(is_caught == 1, fielder_name, "Hit (No Catch)"),
      hover_txt = paste0(
        "<b>Batter:</b> ", player_name, "<br>",
        "<b>Fielder:</b> ", display_fielder, "<br>",
        "<b>Event:</b> ", events, "<br>",
        "------------------<br>",
        "<b>Exit Velo:</b> ", round(launch_speed, 1), " mph<br>",
        "<b>Launch Angle:</b> ", round(launch_angle, 1), "°<br>",
        "<b>Distance:</b> ", round(hit_distance_sc, 0), " ft<br>",
        "<b>Catch Prob:</b> ", round(catch_prob * 100, 1), "%"
      )
    )

  if(nrow(data_t) == 0) next
  
  # Split Data into Hits (for X markers) and Outs (for Dots)
  data_hits <- data_t %>% filter(is_caught == 0) # Hits + HRs
  data_outs <- data_t %>% filter(is_caught == 1) # Outs
  
  is_visible <- (i == 1)
  
  # --- TRACE 1: Grass ---
  fig <- fig %>% add_polygons(
    x = c(0, poly_t$x, 0), y = c(0, poly_t$y, 0),
    fillcolor = "#35682d", opacity = 0.8, line = list(color = "white", width = 2),
    name = paste(t, "Field"), visible = is_visible, hoverinfo = "skip"
  )
  
  # --- TRACE 2: Infield ---
  fig <- fig %>% add_polygons(
    data = infield, x = ~x, y = ~y,
    fillcolor = "#8b4513", line = list(color = "black"),
    name = "Infield", visible = is_visible, hoverinfo = "skip"
  )
  
  # --- TRACE 3: HITS (White X's) ---
  # We still apply the filter transform to hits, in case user wants to filter by prob
  base_idx <- (i-1)*4
  scatter_indices <- c(scatter_indices, base_idx + 2, base_idx + 3) # Add Trace 3 and 4 indices
  
  fig <- fig %>% add_markers(
    data = data_hits,
    x = ~coord_x, y = ~coord_y,
    text = ~hover_txt,
    hoverinfo = "text",
    transforms = list(list(type = 'filter', target = ~catch_prob, operation = '<=', value = 1.0)),
    marker = list(
      symbol = "x",          # THE "X" SYMBOL
      size = 5,
      color = "white",       # WHITE COLOR
      line = list(color = "white", width = 1) 
    ),
    name = paste(t, "Hits"), visible = is_visible
  )
  
  # --- TRACE 4: OUTS (Colored Dots) ---
  fig <- fig %>% add_markers(
    data = data_outs,
    x = ~coord_x, y = ~coord_y,
    text = ~hover_txt,
    hoverinfo = "text",
    transforms = list(list(type = 'filter', target = ~catch_prob, operation = '<=', value = 1.0)),
    marker = list(
      symbol = "circle",
      size = 5,
      line = list(color = "white", width = 0.2),
      color = ~catch_prob,
      colorscale = list(c(0, "#00cc00"), c(0.5, "#ffff00"), c(1, "#ff0000")),
      cmin = 0, cmax = 1,
      colorbar = list(title = "Catch Prob")
    ),
    name = paste(t, "Outs"), visible = is_visible
  )
  
  # --- ANNOTATIONS ---
  ann <- list(
    x = 0.5, y = -0.05, 
    xref = "paper", yref = "paper",
    text = paste0("<b>Total Fly Balls Hit: ", format(nrow(data_t), big.mark=","), "</b>"),
    showarrow = FALSE,
    font = list(size = 14, color = "#333"),
    visible = is_visible 
  )
  all_annotations[[i]] <- ann
  
  # --- MENU LOGIC ---
  # Now we must toggle 4 traces per team
  vis_vec <- rep(FALSE, length(valid_teams) * 4)
  vis_vec[(base_idx + 1):(base_idx + 4)] <- TRUE
  
  current_annotations <- all_annotations
  for(k in seq_along(current_annotations)) current_annotations[[k]]$visible <- (k == i)
  
  visibility_list[[i]] <- list(
    method = "update", 
    args = list(list(visible = vis_vec), list(annotations = current_annotations)), 
    label = t
  )
}

# Define Probability Dropdown
# We apply this to ALL scatter traces (Indices 2, 3... 6, 7... etc relative to 0-index)
prob_buttons <- list(
  list(method = "restyle", args = list("transforms[0].value", 1.00, scatter_indices), label = "All Balls (100%)"),
  list(method = "restyle", args = list("transforms[0].value", 0.75, scatter_indices), label = "Challenging (< 75%)"),
  list(method = "restyle", args = list("transforms[0].value", 0.50, scatter_indices), label = "Difficult (< 50%)"),
  list(method = "restyle", args = list("transforms[0].value", 0.25, scatter_indices), label = "Elite Only (< 25%)")
)

# 5. FINAL LAYOUT
fig <- fig %>% layout(
  title = "2024 MLB Fly Balls (Full Season)",
  xaxis = list(visible = FALSE, range = c(-250, 250), fixedrange=TRUE),
  yaxis = list(visible = FALSE, range = c(-20, 480), fixedrange=TRUE),
  showlegend = FALSE,
  plot_bgcolor = "#f0f0f0",
  annotations = all_annotations, 
  updatemenus = list(
    list(
      y = 1.15, x = 0.0, yanchor = "top",
      buttons = visibility_list,
      active = 0, pad = list(r = 10, t = 10)
    ),
    list(
      y = 1.05, x = 0.0, yanchor = "top",
      buttons = prob_buttons,
      active = 0, pad = list(r = 10, t = 10)
    )
  )
)

toWebGL(fig)
```

(White X's represent base hits, colored dots represent caught fly balls)

For clarity, this model represents 50% of all fly balls hit during the 2024 MLB season. Also, fly balls with a 90-100% chance of being caught are excluded for the purpose of clearing up space.

MLB's Statcast measured over 40,000 fly balls during the 2024 season, and had a catch probability calculated for every single one of them. Represented above is the amount of data that Statcast is capable of measuring, along with real fly balls with calculated catch probabilities for each one. Each stadium plot is built with a 5-point drawing system to show the real outfield wall distance.

## Purpose of This Model

The purpose of this model is to visualize and analyze the catch probability of fly balls across every Major League Baseball stadium for the entire 2024 season. By aggregating Statcast data and mapping it onto custom stadium geometries, the tool allows users to see exactly where balls land relative to specific park dimensions—accounting for factors like exit velocity, launch angle, and spray angle. It employs a logistic regression algorithm to estimate the likelihood of a catch (displayed as a color gradient from green to red) and includes logic to "snap" errant data points back into the field of play, ensuring that balls recorded as hits stay within the fences while home runs clear them.

Ultimately, this interactive visualization helps identify how different stadium layouts impact defensive performance and offensive outcomes.