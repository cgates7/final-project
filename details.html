<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Details – Outfield Catch Probability Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-dfb324f25d9b1687192fa8be62ac8f9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Outfield Catch Probability Analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Catch Probability Data Model</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./playermodel.html"> 
<span class="menu-text">Player Model</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./details.html" aria-current="page"> 
<span class="menu-text">Details</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#details-of-the-season-model" id="toc-details-of-the-season-model" class="nav-link active" data-scroll-target="#details-of-the-season-model">Details of the Season Model</a>
  <ul class="collapse">
  <li><a href="#project-abstract" id="toc-project-abstract" class="nav-link" data-scroll-target="#project-abstract">Project Abstract</a></li>
  <li><a href="#data-acquisition-pipeline" id="toc-data-acquisition-pipeline" class="nav-link" data-scroll-target="#data-acquisition-pipeline">Data Acquisition &amp; Pipeline</a></li>
  <li><a href="#methodology-coordinate-transformation" id="toc-methodology-coordinate-transformation" class="nav-link" data-scroll-target="#methodology-coordinate-transformation">Methodology: Coordinate Transformation</a></li>
  <li><a href="#the-stadium-geometry-engine" id="toc-the-stadium-geometry-engine" class="nav-link" data-scroll-target="#the-stadium-geometry-engine">The Stadium Geometry Engine</a></li>
  <li><a href="#visualization-technology" id="toc-visualization-technology" class="nav-link" data-scroll-target="#visualization-technology">Visualization Technology</a></li>
  <li><a href="#future-scope-roadmap" id="toc-future-scope-roadmap" class="nav-link" data-scroll-target="#future-scope-roadmap">Future Scope &amp; Roadmap</a></li>
  </ul></li>
  <li><a href="#details-of-the-player-model-evaluating-outfield-range-efficiency" id="toc-details-of-the-player-model-evaluating-outfield-range-efficiency" class="nav-link" data-scroll-target="#details-of-the-player-model-evaluating-outfield-range-efficiency">Details of the Player Model: Evaluating Outfield Range &amp; Efficiency</a>
  <ul class="collapse">
  <li><a href="#conceptual-framework" id="toc-conceptual-framework" class="nav-link" data-scroll-target="#conceptual-framework">Conceptual Framework</a></li>
  <li><a href="#feature-engineering" id="toc-feature-engineering" class="nav-link" data-scroll-target="#feature-engineering">Feature Engineering</a></li>
  <li><a href="#the-probability-algorithm" id="toc-the-probability-algorithm" class="nav-link" data-scroll-target="#the-probability-algorithm">The Probability Algorithm</a></li>
  <li><a href="#performance-metrics-outs-above-average-oaa" id="toc-performance-metrics-outs-above-average-oaa" class="nav-link" data-scroll-target="#performance-metrics-outs-above-average-oaa">Performance Metrics: Outs Above Average (OAA)</a></li>
  <li><a href="#zone-visualization-spray-charts" id="toc-zone-visualization-spray-charts" class="nav-link" data-scroll-target="#zone-visualization-spray-charts">Zone Visualization &amp; Spray Charts</a></li>
  <li><a href="#model-limitations-future-adjustments" id="toc-model-limitations-future-adjustments" class="nav-link" data-scroll-target="#model-limitations-future-adjustments">Model Limitations &amp; Future Adjustments</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Details</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="details-of-the-season-model" class="level2">
<h2 class="anchored" data-anchor-id="details-of-the-season-model">Details of the Season Model</h2>
<section id="project-abstract" class="level3">
<h3 class="anchored" data-anchor-id="project-abstract">Project Abstract</h3>
<p>The <strong>Outfield Catch Probability Analysis</strong> is a data visualization and analytics model designed to evaluate the spatial distribution of batted balls in Major League Baseball (MLB). By leveraging 2024 Statcast data, this project maps the precise landing coordinates of fly balls and line drives against custom-rendered stadium geometries. The goal is to identify “dead zones” where hits are probable and compare defensive performance across different MLB ballparks, visualizing the fine line between a game-saving catch and an extra-base hit.</p>
</section>
<section id="data-acquisition-pipeline" class="level3">
<h3 class="anchored" data-anchor-id="data-acquisition-pipeline">Data Acquisition &amp; Pipeline</h3>
<p>The analysis is powered by MLB’s <strong>Statcast</strong> system, which utilizes high-resolution cameras and radar equipment to track ball and player movements.</p>
<ul>
<li><strong>Source:</strong> <a href="https://baseballsavant.mlb.com/">Baseball Savant / MLB Statcast</a></li>
<li><strong>Scope:</strong> The dataset currently focuses on the 2024 Regular Season, filtering for outcomes classified as fly balls (<code>bb_type != 'ground_ball'</code>) to isolate outfield play.</li>
<li><strong>Key Variables:</strong>
<ul>
<li><strong>Launch Metrics:</strong> Exit Velocity (<code>launch_speed</code>), Launch Angle (<code>launch_angle</code>), and Hang Time.</li>
<li><strong>Outcome Data:</strong> Event classifications (<code>field_out</code>, <code>home_run</code>, <code>single</code>, <code>double</code>, <code>triple</code>).</li>
<li><strong>Coordinates:</strong> Raw <code>hc_x</code> and <code>hc_y</code> (Hit Coordinates) provided by the MLB API.</li>
</ul></li>
</ul>
</section>
<section id="methodology-coordinate-transformation" class="level3">
<h3 class="anchored" data-anchor-id="methodology-coordinate-transformation">Methodology: Coordinate Transformation</h3>
<p>One of the core technical challenges of this project was translating MLB’s standardized API coordinates into real-world stadium dimensions (measured in feet). The Statcast API provides coordinates on a generic 0-250 scale which does not map 1:1 to physical field dimensions.</p>
<p>To solve this, I implemented a coordinate transformation algorithm within the R data pipeline:</p>
<p><span class="math display">\[X_{field} = (hc_x - 125.42) \times 2.5\]</span> <span class="math display">\[Y_{field} = (198.27 - hc_y) \times 2.5\]</span> <span class="math display">\[\theta = \arctan(X_{field}, Y_{field})\]</span></p>
<ul>
<li><strong>Centering:</strong> The origin <span class="math inline">\((0,0)\)</span> is recalibrated to Home Plate.</li>
<li><strong>Scaling:</strong> A scaling factor of <code>2.5</code> is applied to convert the coordinate units into approximate feet.</li>
<li><strong>Rotation:</strong> Trigonometric functions (<code>atan2</code>) are used to calculate the spray angle of the ball, allowing for analysis of pull-side vs.&nbsp;opposite-field power.</li>
</ul>
</section>
<section id="the-stadium-geometry-engine" class="level3">
<h3 class="anchored" data-anchor-id="the-stadium-geometry-engine">The Stadium Geometry Engine</h3>
<p>A standardized field cannot capture the nuances of baseball, where every park has unique dimensions (e.g., the “Green Monster” in Boston vs.&nbsp;the “Short Porch” in New York).</p>
<p>I developed a <strong>Stadium Geometry Engine</strong> that renders custom polygon shapes for individual stadiums based on their official wall distances: * <strong>Vector Mapping:</strong> The engine takes distance inputs for Left Field, Left-Center, Center, Right-Center, and Right Field. * <strong>Spline Interpolation:</strong> A cubic spline algorithm smooths the connection between these wall points to create a realistic curved outfield fence. * <strong>Layering:</strong> The visualization layers the grass field, dirt infield, and foul lines to provide accurate context for every data point.</p>
</section>
<section id="visualization-technology" class="level3">
<h3 class="anchored" data-anchor-id="visualization-technology">Visualization Technology</h3>
<p>The project is built using <strong>R</strong> and <strong>Quarto</strong>, utilizing the <strong>Plotly</strong> library for high-performance interactivity.</p>
<ul>
<li><strong>Interactive Hover:</strong> Users can hover over any specific data point to view the batter’s name, the specific event (e.g., “Sac Fly”), and the distance traveled.</li>
<li><strong>Outcome Color Coding:</strong>
<ul>
<li><strong>Blue Markers:</strong> Represent Hits (Singles, Doubles, Triples, Home Runs).</li>
<li><strong>Orange Markers:</strong> Represent Outs (Field Outs, Sac Flies).</li>
</ul></li>
<li><strong>Performance:</strong> The rendering engine handles thousands of data points while maintaining responsive zooming and panning capabilities, allowing users to inspect cluster density in the gaps.</li>
</ul>
</section>
<section id="future-scope-roadmap" class="level3">
<h3 class="anchored" data-anchor-id="future-scope-roadmap">Future Scope &amp; Roadmap</h3>
<p>This project serves as a foundation for more advanced defensive analytics. Future iterations will include: * <strong>Hang Time Integration:</strong> Incorporating hang time to differentiate “easy” fly balls from “5-star” diving plays. * <strong>Fielder Positioning:</strong> Overlaying starting fielder positions to calculate “Distance Needed to Travel” vs.&nbsp;“Opportunity Time.” * <strong>3D Trajectory Mapping:</strong> expanding the 2D landing spots into 3D flight paths.</p>
</section>
</section>
<section id="details-of-the-player-model-evaluating-outfield-range-efficiency" class="level2">
<h2 class="anchored" data-anchor-id="details-of-the-player-model-evaluating-outfield-range-efficiency">Details of the Player Model: Evaluating Outfield Range &amp; Efficiency</h2>
<section id="conceptual-framework" class="level3">
<h3 class="anchored" data-anchor-id="conceptual-framework">Conceptual Framework</h3>
<p>The <strong>Player Model</strong> is the analytical engine designed to isolate an outfielder’s individual skill from the context of the game. While the visualizer displays <em>what happened</em> (Out vs.&nbsp;Hit), the Player Model attempts to answer <em>what should have happened</em>.</p>
<p>The core philosophy relies on <strong>Opportunity Analysis</strong>: evaluating a player not by raw putouts, but by their conversion rate on plays of varying difficulty.</p>
</section>
<section id="feature-engineering" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering">Feature Engineering</h3>
<p>To assess catch probability, the model ingests specific vector inputs for every batted ball hit into a player’s zone.</p>
<ul>
<li><strong>Opportunity Time (<span class="math inline">\(T_{opp}\)</span>):</strong> The precise duration the ball is in the air (Hang Time).</li>
<li><strong>Distance Traveled (<span class="math inline">\(D_{dist}\)</span>):</strong> The linear distance from home plate to the landing spot.</li>
<li><strong>Distance Needed (<span class="math inline">\(D_{need}\)</span>):</strong> The distance the fielder must cover from their starting position to the landing spot. <em>(Note: In the current iteration, this is approximated using average positioning centroids).</em></li>
<li><strong>Wall Proximity (<span class="math inline">\(W_{prox}\)</span>):</strong> A binary or continuous variable penalizing catch probability when the landing spot is close to the outfield wall, accounting for the “fear of collision” factor.</li>
</ul>
</section>
<section id="the-probability-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-probability-algorithm">The Probability Algorithm</h3>
<p>The backbone of the model is a <strong>Logistic Regression</strong> classifier (or Generalized Linear Model). We model the probability of a catch (<span class="math inline">\(P_{catch}\)</span>) as a function of the distance needed to travel versus the time available to get there.</p>
<p>The fundamental equation used to estimate the difficulty of a play is:</p>
<p><span class="math display">\[P(Catch) = \frac{1}{1 + e^{-(\beta_0 + \beta_1 \cdot D_{need} + \beta_2 \cdot T_{opp} + \beta_3 \cdot \theta_{dir})}}\]</span></p>
<p>Where: * <span class="math inline">\(\beta\)</span> represents the learned coefficients from league-wide data. * <span class="math inline">\(\theta_{dir}\)</span> accounts for the direction (running back is harder than running forward). * The output is a probability value between 0 (Impossible) and 1 (Routine).</p>
</section>
<section id="performance-metrics-outs-above-average-oaa" class="level3">
<h3 class="anchored" data-anchor-id="performance-metrics-outs-above-average-oaa">Performance Metrics: Outs Above Average (OAA)</h3>
<p>Using the probability outputs, we derive the primary metric: <strong>Outs Above Average (OAA)</strong>. This is a cumulative metric that quantifies how many outs a player has saved (or lost) compared to an average MLB outfielder.</p>
<p>The calculation for a single play is defined as:</p>
<ul>
<li><p><strong>If the Catch is Made:</strong> <span class="math display">\[Score = 1 - P(Catch)\]</span> <em>(Example: Catching a ball with a 30% probability grants +0.70 credit).</em></p></li>
<li><p><strong>If the Ball Drops (Hit):</strong> <span class="math display">\[Score = 0 - P(Catch)\]</span> <em>(Example: Missing a ball with a 90% catch probability results in -0.90 debit).</em></p></li>
</ul>
</section>
<section id="zone-visualization-spray-charts" class="level3">
<h3 class="anchored" data-anchor-id="zone-visualization-spray-charts">Zone Visualization &amp; Spray Charts</h3>
<p>For the visual component of the Player Model, we utilize <strong>Kernel Density Estimation (KDE)</strong> to generate heatmaps of a player’s activity.</p>
<ul>
<li><strong>The “Green Zone”:</strong> Areas where the player converts &gt;90% of opportunities.</li>
<li><strong>The “Red Zone”:</strong> Areas where the player consistently underperforms expected catch rates.</li>
<li><strong>Shift Analysis:</strong> By plotting the centroid of a player’s fielding events, we can visualize their defensive tendencies (e.g., playing deep to prevent doubles vs.&nbsp;shallow to prevent singles).</li>
</ul>
</section>
<section id="model-limitations-future-adjustments" class="level3">
<h3 class="anchored" data-anchor-id="model-limitations-future-adjustments">Model Limitations &amp; Future Adjustments</h3>
<ul>
<li><strong>Jump/Reaction:</strong> The current model assumes a standardized reaction time. Future versions will integrate “First Step” data to separate reaction speed from sprint speed.</li>
<li><strong>Route Efficiency:</strong> We aim to incorporate route efficiency metrics (actual distance run vs.&nbsp;optimal straight-line distance) to penalize poor pathfinding even if the catch is made.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/cgates7\.github\.io\/catch-probability-analysis\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>